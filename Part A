#-----------START OF SOURCED CODE------------
# The following code is sourced from:
# Lynn Root (screen name: econchick) (30/01/2013) Python implementation of Dijkstra's Algorithm (Version 1.0) [source code]. https://gist.github.com/econchick/4666413
class Graph:
  def __init__(self):
    self.nodes = set()
    self.edges = defaultdict(list)
    self.distances = {}

  def add_node(self, value):
    self.nodes.add(value)

  def add_edge(self, from_node, to_node, distance):
    self.edges[from_node].append(to_node)
    self.edges[to_node].append(from_node)
    self.distances[(from_node, to_node)] = distance


def dijsktra(graph, initial):
  visited = {initial: 0}
  path = {}

  nodes = set(graph.nodes)

  while nodes: 
    min_node = None
    for node in nodes:
      if node in visited:
        if min_node is None:
          min_node = node
        elif visited[node] < visited[min_node]:
          min_node = node

    if min_node is None:
      break

    nodes.remove(min_node)
    current_weight = visited[min_node]

    for edge in graph.edges[min_node]:
      weight = current_weight + graph.distance[(min_node, edge)]
      if edge not in visited or weight < visited[edge]:
        visited[edge] = weight
        path[edge] = min_node

  return visited, path
        
 #------------END OF SOURCED CODE-------------


def main():

    #Define symbols
    empty = '-'
    white = 'O'
    black = '@'
    
    # initialise board matrix
    board = [[0 for col in range(8)] for row in range(8)]
    attackers = []
    targets = []
    goals = []
    flanks = []
    
    # Load board and game_type
    for i in range(8):
        board[i] = input().replace(" ", "")
    game_type = input()


    # Check game_type
    #------------------------MOVES------------------------
    if input is Moves:

        # Initialise moves variables
        moves_O = 0
        moves_at = 0
    
        # For each square on board:
        #       - check if it's a piece
        #       - if so, count avaliable moves 
     
        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    #Check avaliable spaces
                    moves_O += CheckMoves(board,x,y)
                
                elif board[x][y] is black:
                    #Check avaliable spaces
                    moves_at += CheckMoves(board,x,y)

        print(moves_O +'\n' + moves_at)
    
    
    #---------------------MASSACRE----------------------
    elif input is Massacre:
       # Store locations of Black and White pieces

       num_white = 0
       num_black = 0

       for x in range(8):
           for y range(8):
               if board[x][y] is white:
                   attackers.append((x,y))
                   num_white += 1

               elif board[x][y] is black:
                   targets.append((x,y))
                   num_black += 1

       for i in targets:
           x = i[0]
           y = i[1]
           returns = find_goal_pos(goals, flanks,x,y)
           goals = returns[0]
           flanks = returns[1]
           
           
      #for i in range(num_white):
       #   if in_goal_pos(attackers[i]):
       #       i += 1
        #  else
           #   it_depth_search(attackers[i])


#------------------HELPER FUNCTIONS-----------------

# Function to check the avaliable moves surrounding a piece

def CheckMoves(board, x, y):
    moves = 0
    if board[x+1][y] is '-':
        moves+=1
    if board[x-1][y] is '-':
        moves+=1
    if board[x][y+1] is '-':
        moves+=1
    if board[x][y-1] is '-':
        moves+=1
        
    if (x+2 in range(8)) and (board[x+1][y] is 'O' or '@') and (board[x+2][y] is '-'):
        moves+=1
    if (x-2 in range(8)) and (board[x-1][y] is 'O' or '@') and (board[x-2][y] is '-'):
        moves+=1
    if (y+2 in range(8)) and (board[x][y+1] is 'O' or '@') and (board[x][y+2] is '-'):
        moves+=1
    if (y-2 in range(8)) and (board[x][y-1] is 'O' or '@') and (board[x][y-2] is '-'):
        moves+=1
        
    return moves
    
# Check if piece already partially surrounded and mark goal positions for white

def find_goal_pos(goals,flanks,x,y):

    # If no white pieces surround black, all surrounding tiles are valid goals

    if (board[x+1][y] is empty and board[x-1][y] is empty
    and board[x][y+1] is empty and board[x][y-1] is empty):

        goals.append((x+1,y))
        goals.append((x-1,y))
        goals.append((x,y+1))
        goals.append((x,y-1))

    # If piece already surrounded by one white piece, adjacent square is goal

    if (board[x+1][y] is white):
        goals.append((x-1,y))
        flanks.append(attackers.pop(attackers.index((x+1,y))))
    if (board[x-1][y] is white):
        goals.append((x+1,y))
        flanks.append(attackers.pop(attackers.index((x-1,y))))
    if (board[x][y+1] is white):
        goals.append((x,y-1))
        flanks.append(attackers.pop(attackers.index((x,y+1))))
    if (board[x][y-1] is white):
        goals.append((x,y+1))
        flanks.append(attackers.pop(attackers.index((x,y-1))))
    
    return [goals,flanks]

def in_goal_pos(x,y):

    # Check that the white piece is in a goal pos

    if (board[x+1][y] is black or board[x-1][y] is black
    or board[x][y+1] is black or board[x][y-1] is black):
        return True
    else
        return False

def check_taken(x,y):


def check_win(board):


