class Dijkstra():
    def dijkstra(): #or it_depth_search():
        #initialise and search
        # can probably just copy and paste here, with citation


def main():

    #Define symbols
    empty = '-'
    white = 'O'
    black = '@'
    
    # initialise board matrix
    board = [[0 for col in range(8)] for row in range(8)]
    attackers = []
    targets = []
    goals = []
    flanks = []
    
    # Load board and game_type
    for i in range(8):
        board[i] = input().replace(" ", "")
    game_type = input()


    # Check game_type
    #------------------------MOVES------------------------
    if input is Moves:

        # Initialise moves variables
        moves_O = 0
        moves_at = 0
    
        # For each square on board:
        #       - check if it's a piece
        #       - if so, count avaliable moves 
     
        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    #Check avaliable spaces
                    moves_O += CheckMoves(board,x,y)
                
                elif board[x][y] is black:
                    #Check avaliable spaces
                    moves_at += CheckMoves(board,x,y)

        print(moves_O +'\n' + moves_at)
    
    
    #---------------------MASSACRE----------------------
    elif input is Massacre:
       # Store locations of Black and White pieces

       num_white = 0
       num_black = 0

       for x in range(8):
           for y range(8):
               if board[x][y] is white:
                   attackers.append((x,y))
                   num_white += 1

               elif board[x][y] is black:
                   targets.append((x,y))
                   num_black += 1

       for i in targets:
           x = i[0]
           y = i[1]
           returns = find_goal_pos(goals, flanks,x,y)
           goals = returns[0]
           flanks = returns[1]
           
           
      #for i in range(num_white):
       #   if in_goal_pos(attackers[i]):
       #       i += 1
        #  else
           #   it_depth_search(attackers[i])


#------------------HELPER FUNCTIONS-----------------

# Function to check the avaliable moves surrounding a piece

def CheckMoves(board, x, y):
    moves = 0
    if board[x+1][y] is '-':
        moves+=1
    if board[x-1][y] is '-':
        moves+=1
    if board[x][y+1] is '-':
        moves+=1
    if board[x][y-1] is '-':
        moves+=1
        
    if (x+2 in range(8)) and (board[x+1][y] is 'O' or '@') and (board[x+2][y] is '-'):
        moves+=1
    if (x-2 in range(8)) and (board[x-1][y] is 'O' or '@') and (board[x-2][y] is '-'):
        moves+=1
    if (y+2 in range(8)) and (board[x][y+1] is 'O' or '@') and (board[x][y+2] is '-'):
        moves+=1
    if (y-2 in range(8)) and (board[x][y-1] is 'O' or '@') and (board[x][y-2] is '-'):
        moves+=1
        
    return moves
    
# Check if piece already partially surrounded and mark goal positions for white

def find_goal_pos(goals,flanks,x,y):

    # If no white pieces surround black, all surrounding tiles are valid goals

    if (board[x+1][y] is empty and board[x-1][y] is empty
    and board[x][y+1] is empty and board[x][y-1] is empty):

        goals.append((x+1,y))
        goals.append((x-1,y))
        goals.append((x,y+1))
        goals.append((x,y-1))

    # If piece already surrounded by one white piece, adjacent square is goal

    if (board[x+1][y] is white):
        goals.append((x-1,y))
        flanks.append(attackers.pop(attackers.index((x+1,y))))
    if (board[x-1][y] is white):
        goals.append((x+1,y))
        flanks.append(attackers.pop(attackers.index((x-1,y))))
    if (board[x][y+1] is white):
        goals.append((x,y-1))
        flanks.append(attackers.pop(attackers.index((x,y+1))))
    if (board[x][y-1] is white):
        goals.append((x,y+1))
        flanks.append(attackers.pop(attackers.index((x,y-1))))
    
    return [goals,flanks]

def in_goal_pos(x,y):

    # Check that the white piece is in a goal pos

    if (board[x+1][y] is black or board[x-1][y] is black
    or board[x][y+1] is black or board[x][y-1] is black):
        return True
    else
        return False

def check_taken(x,y):


def check_win(board):


