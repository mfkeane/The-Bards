#Constants
empty = '-'
white = 'O'
black = '@'

class WatchYourBack:

    # Function to check the avaliable moves surrounding a piece
    def check_moves(board, x, y):
        moves = 0
        if (x+1 in range(8)) and board[x+1][y] is '-':
            moves+=1
        if (x-1 in range(8)) and board[x-1][y] is '-':
            moves+=1
        if (y+1 in range(8)) and board[x][y+1] is '-':
            moves+=1
        if (y-1 in range(8)) and board[x][y-1] is '-':
            moves+=1

        if (x+2 in range(8)) and ((board[x+1][y] is 'O')
        or (board[x+1][y] is '@'))$
            moves+=1
        if (x-2 in range(8)) and ((board[x-1][y] is 'O')
        or (board[x-1][y] is '@'))$
            moves+=1
        if (y+2 in range(8)) and ((board[x][y+1] is 'O')
        or (board[x][y+1] is '@'))$
            moves+=1
        if (y-2 in range(8)) and ((board[x][y-1] is 'O')
        or (board[x][y-1] is '@'))$
            moves+=1

        return moves

    # Appends avaliable moves to a list
    def append_moves(board, x, y):
        moves = []
        if (x+1 in range(8)) and board[x+1][y] is '-':
            moves.append((x+1,y))
        if (x-1 in range(8)) and board[x-1][y] is '-':
            moves.append((x-1,y))
        if (y+1 in range(8)) and board[x][y+1] is '-':
            moves.append((x,y+1))
        if (y-1 in range(8)) and board[x][y-1] is '-':
            moves.append((x,y-1))

        if (x+2 in range(8)) and ((board[x+1][y] is 'O')
        or (board[x+1][y] is '@'))$
            moves.append((x+2,y))
        if (x-2 in range(8)) and ((board[x-1][y] is 'O')
        or (board[x-1][y] is '@'))$
            moves.append((x-2,y))
        if (y+2 in range(8)) and ((board[x][y+1] is 'O')
        or (board[x][y+1] is '@'))$
            moves.append((x,y+2))
        if (y-2 in range(8)) and ((board[x][y-1] is 'O')
        or (board[x][y-1] is '@'))$
            moves.append((x,y-2))

        return moves

    # Check if piece already partially surrounded
    #   and mark goal positions for white
    def find_goal_pos(goals,flanks,x,y):

        # If no white pieces surround black,
        #   all surrounding tiles are valid goals

        if (board[x+1][y] is empty and board[x-1][y] is empty
        and board[x][y+1] is empty and board[x][y-1] is empty):

            goals.append((x+1,y))
            goals.append((x-1,y))
            goals.append((x,y+1))
            goals.append((x,y-1))

        # If piece already surrounded by one white piece,
        #   adjacent square is goal

        if (board[x+1][y] is white):
            goals.append((x-1,y))
            flanks.append(attackers.pop(attackers.index((x+1,y))))
        if (board[x-1][y] is white):
            goals.append((x+1,y))
            flanks.append(attackers.pop(attackers.index((x-1,y))))
        if (board[x][y+1] is white):
            goals.append((x,y-1))
            flanks.append(attackers.pop(attackers.index((x,y+1))))
        if (board[x][y-1] is white):
            goals.append((x,y+1))
            flanks.append(attackers.pop(attackers.index((x,y-1))))

        return [goals,flanks]

    def in_goal_pos(x,y):

        # Check that the white piece is in a goal pos

        if (board[x+1][y] is black or board[x-1][y] is black
        or board[x][y+1] is black or board[x][y-1] is black):
            return True
        else
            return False

    def find_closest_goal(piece,goals):
        closest = goals[0]
        dist = 16
        for place in goals:
            if (abs((piece[0]-place[0])+(piece[1]-place[1])))<dist:
                dist = abs((piece[0]-place[0])+(piece[1]-place[1])))
                closest = place
        return closest

"""    def check_taken(x,y):


    def check_win(board):"""

    # not sure if works yet
    # Searching algorithm function: Depth Limited Search
    def depth_limited_search(board, curr_pos, goal, path, depth):
        if curr_pos == goal:
            return path
        if depth <= 0:
            return None
        else:
            children = append_moves(board, curr_pos[0], curr_pos[1])
            for coord in children:
                search = path """Necessary???"""
                search.append(coord)
                result = depth_limited_search(board, path[-1], goal, search,
                depth-1) """Path -1???"""
            if result is not None:
                return result """Potentially returns nothing???
                                 If result is none, the current recurision will end and 
                                 it should jump back up to the last recursion"""

#------------------------MOVES------------------------

    def moves(board):
        # Initialise moves variables
        moves_O = 0
        moves_at = 0

        # For each square on board:
        #       - check if it's a piece
        #       - if so, count avaliable moves

        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    #Check avaliable spaces
                    moves_O += check_moves(board,x,y)

                elif board[x][y] is black:
                    #Check avaliable spaces
                    moves_at +=
                    (board,x,y)


        print(str(moves_O) + "\n" + str(moves_at))
        return [moves_O, moves_at]

#---------------------MASSACRE----------------------

    def massacre(board):

         moves = []

        # Store locations of Black and White pieces
        for x in range(8):
           for y range(8):
               if board[x][y] is white:
                   attackers.append((x,y))

               elif board[x][y] is black:
                   targets.append((x,y))

        for i in targets:
            x = i[0]
            y = i[1]
            returns = find_goal_pos(goals, flanks,x,y)
            goals = returns[0]
            flanks = returns[1]

        # While all black pieces are not dead
        while len(targets)>0:
            for attacker in attackers:
            #for i in range(len(attackers)):
            # if attacker is not being helpful, put it somewhere better
                if not in_goal_pos(attacker):
                    closest_goal = find_closest_goal(attacker, goals)
                    moves.append(depth_limited_search(board, attacker,
                    closest_goal, path, depth))

                    # Remove current goal from goal list
                    for goal in goals:
                        if goal == attacker:
                            goals.remove(goal)

                    #move O to O_goal_list
                    flanks.append(attackers.pop(attacker))

                    """for j in range(len(goals)):
                        if attackers[i] in goals:
                            goals.remove(attackers[i])"""

                    # -----Check if target is dead-----
                    # find opposite flank
                    (x,y) = attacker
                    if (x+2 in range(8)) and board[x+1][y] is black):
                        curr_target = (x+1,y)
                        flanker = (x+2,y)
                    if (x-2 in range(8)) and board[x-1][y] is black):
                        curr_target = (x-1,y)
                        flanker = (x-2,y)
                    if (y+2 in range(8)) and board[x][y+1] is black):
                        curr_target = (x,y+1)
                        flanker = (x,y+2)
                    if (y-2 in range(8)) and board[x][y-1] is black):
                        curr_target = (x, y-1)
                        flanker = (x, y-2)

                    (flank_x, flank_y) = flanker
                    """#(x,y) = attacker
                    #(x_tar, y_tar) = curr_target
                    flanker = (x+(x_tar-x), y+(y_tar-y)) """"

                    # if opposite flank is also in flanking list
                    if flanker in flanks:
                        # target dead

                        # remove all associated goal's from list
                        #   (except already removed one)
                        for coord in find_goal_pos([],[],x_tar, y_tar)[0]:
                            if coord is not attacker:
                                goals.remove(coord)

                        # remove current target from target list as it's dead
                        targets.remove(curr_target)

                        # move associated flankers from flanker list to
                        #   attackers if coords no longer in goal list
                        if (x,y) not in goals and board[x][y-1] is not black
                        and board[x][y+1] is not black
                        and board[x-1][y] is not black
                        and board[x+1][y] is not black):
                            attackers.append(flanks.pop(attacker))
                        if flanker not in goals
                        and board[flank_x][flank_y-1] is not black
                        and board[flank_x][flank_y+1] is not black
                        and board[flank_x-1][flank_y] is not black
                        and board[flank_x+1][flank_y] is not black:
                            attackers.append(flanks.pop(flanker))

            for i in range(len(moves)-1):
                print(moves[i] + " -> " moves[i+1])

            return moves


# --------------------MAIN----------------------

# initialise board matrix
board = [[0 for col in range(8)] for row in range(8)]
attackers = []
targets = []
goals = []
flanks = []

# Load board and game_type
for i in range(8):
    line = input()
    board[i] = line.replace(" ","")
game_type = input()
print(game_type)

# Check game_type

if game_type == "Moves":
    moves(board)
elif input == "Massacre":
    massacre(board)
