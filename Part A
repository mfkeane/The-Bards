# Constants
empty = '-'
white = 'O'
black = '@'
corner = 'X'


class WatchYourBack:

    # Function to check the avaliable moves surrounding a piece
    def check_moves(board, x, y):
        moves = 0
        # Check square to right
        if (x+1 in range(8)) and (board[x+1][y] is empty):
            moves += 1
        # Check square to left
        if (x-1 in range(8)) and (board[x-1][y] is empty):
            moves += 1
        # Check square below
        if (y+1 in range(8)) and (board[x][y+1] is empty):
            moves += 1
        # Check square above
        if (y-1 in range(8)) and (board[x][y-1] is empty):
            moves += 1

        # Check if piece can jump to right
        if (x+2 in range(8)) and ((board[x+1][y] is white) or
           (board[x+1][y] is black)):
            moves += 1
        # Check if piece can jump to left
        if (x-2 in range(8)) and ((board[x-1][y] is white) or
           (board[x-1][y] is black)):
            moves += 1
        # Check if piece can jump down
        if (y+2 in range(8)) and ((board[x][y+1] is white) or
           (board[x][y+1] is black)):
            moves += 1
        # Check if piece can jump up
        if (y-2 in range(8)) and ((board[x][y-1] is white) or
           (board[x][y-1] is black)):
            moves += 1

        return moves

    # Appends avaliable moves to a list
    def append_moves(board, x, y, path):
        moves = []
        if (x+1 in range(8)) and board[x+1][y] is empty:
            # Only append if not already a square that has been moved to
            if (x+1, y) not in path:
                moves.append((x+1, y))
        if (x-1 in range(8)) and board[x-1][y] is empty:
            if (x-1, y) not in path:
                moves.append((x-1, y))
        if (y+1 in range(8)) and board[x][y+1] is empty:
            if (x, y+1) not in path:
                moves.append((x, y+1))
        if (y-1 in range(8)) and board[x][y-1] is empty:
            if (x, y-1) not in path:
                moves.append((x, y-1))

        if ((x+2 in range(8)) and ((board[x+1][y] is white) or
           (board[x+1][y] is black)) and board[x+2][y] is empty):
            if (x+2, y) not in path:
                moves.append((x+2, y))
        if ((x-2 in range(8)) and ((board[x-1][y] is white) or
           (board[x-1][y] is black)) and board[x-2][y] is empty):
            if (x-2, y) not in path:
                moves.append((x-2, y))
        if ((y+2 in range(8)) and ((board[x][y+1] is white) or
           (board[x][y+1] is black)) and board[x][y+2] is empty):
            if (x, y+2) not in path:
                moves.append((x, y+2))
        if ((y-2 in range(8)) and ((board[x][y-1] is white) or
           (board[x][y-1] is black)) and board[x][y-2] is empty):
            if (x, y-2) not in path:
                moves.append((x, y-2))

        return moves

    def move_flank_to_attack(targets, goals, attackers, flanks, x, y):
        if ((x,y) not in goals and
         (board[x][y] is not corner) and
         ((x+1, y) not in targets and 
         (x-1, y) not in targets and 
         (x, y+1) not in targets and 
         (x, y-1) not in targets)):
            attackers.append(flanks.pop(flanks.index((x,y))))

    def remove_kamikaze(goal):
        x = goal[0]
        y = goal[1]

        if (x in range(1,7) and (board[x+1][y] is black 
            and board[x-1][y] is black) and 
           ((x+2 in range(8) and board[x+2][y] is not white) or (x+2 not in 
           range(8))) and
           ((x-2 in range(8) and board[x-2][y] is not white) or (x+2 not in
           range(8)))):

            remove_goal_pos(goals, x, y)

        if (y in range(1,7) and (board[y+1][y] is black 
           and board[y-1][y] is black) and 
           ((y+2 in range(8) and board[y+2][y] is not white) or (y+2 not in 
           range(8))) and
           ((y-2 in range(8) and board[y-2][y] is not white) or (y+2 not in
           range(8)))):
           
            remove_goal_pos(goals, x, y)

    # Check if piece already partially surrounded
    #   and mark goal positions for white
    def find_goal_pos(goals, flanks, x, y):

        # If no white pieces surround black,
        #   all surrounding tiles are valid goals

        if (x in range(1,7) and y in range(1,7) and board[x+1][y] is empty 
           and board[x-1][y] is empty and board[x][y+1] is empty 
           and board[x][y-1] is empty):

            goals.append((x+1, y))
            goals.append((x-1, y))
            goals.append((x, y+1))
            goals.append((x, y-1))

        # If piece already surrounded by one white piece,
        #   or is next to a corner, opposite square is goal

        if ((x+1 in range(8)) and (x-1 in range(8)) and ((board[x+1][y] is
           white) or board[x+1][y] is corner)):
            goals.append((x-1, y))
            if board[x+1][y] is white and (x+1,y) in attackers:
                flanks.append(attackers.pop(attackers.index((x+1, y))))
        if ((x-1 in range(8)) and (x+1 in range(8)) and ((board[x-1][y] is
           white) or board[x-1][y] is corner)):
            goals.append((x+1, y))
            if board[x-1][y] is white and (x-1,y) in attackers:
                flanks.append(attackers.pop(attackers.index((x-1, y))))
        if ((y+1 in range(8)) and (y-1 in range(8)) and ((board[x][y+1] is
           white) or board[x][y+1] is corner)):
            goals.append((x, y-1))
            if board[x][y+1] is white and (x,y+1) in attackers:
                flanks.append(attackers.pop(attackers.index((x, y+1))))
        if ((y-1 in range(8)) and (y+1 in range(8)) and ((board[x][y-1] is
           white) or board[x][y-1] is corner)):
            goals.append((x, y+1))
            if board[x][y-1] is white and (x,y-1) in attackers:
                flanks.append(attackers.pop(attackers.index((x, y-1))))

        # if black on edge of board
        if ((x+1 not in range(8)) and ((y+1 in range(8) and board[x][y+1] is 
           empty) and ((y-1 in range(8)) and board[x][y-1] is empty))):
            goals.append((x,y+1))
            goals.append((x,y-1))
        if ((x-1 not in range(8)) and ((y+1 in range(8) and board[x][y+1] is 
           empty) and ((y-1 in range(8)) and board[x][y-1] is empty))):
            goals.append((x,y+1))
            goals.append((x,y-1))
        if ((y+1 not in range(8)) and ((x+1 in range(8) and board[x+1][y] is 
           empty) and ((x-1 in range(8)) and board[x-1][y] is empty))):
            goals.append((x+1,y))
            goals.append((x-1,y))
        if ((y-1 not in range(8)) and ((x+1 in range(8) and board[x+1][y] is 
           empty) and ((x-1 in range(8)) and board[x-1][y] is empty))):
            goals.append((x+1,y))
            goals.append((x-1,y))
            

        for goal in goals:
            WatchYourBack.remove_kamikaze(goal)

        return [goals, flanks]

    # Remove co-ordinate from goal list
    def remove_goal_pos(goals, x, y):

        if ((x+1, y) in goals and (x+2,y) not in targets and (x+1,y+1) not in
         targets and (x+1,y-1) not in targets):
            goals.remove((x+1, y))
        if ((x-1, y) in goals and (x-2,y) not in targets and (x-1,y+1) not in
         targets and (x-1,y-1) not in targets):
            goals.remove((x-1, y))
        if ((x, y+1) in goals and (x,y+2) not in targets and (x-1,y+1) not in
         targets and (x+1,y+1) not in targets):
            goals.remove((x, y+1))
        if ((x, y-1) in goals and (x,y-2) not in targets and (x-1,y-1) not in
         targets and (x+1,y-1) not in targets):
            goals.remove((x, y-1))

    # Check that the white piece is in a goal pos
    def in_goal_pos(targets, x, y):

        if ((x+1, y) in targets or 
        (x-1, y) in targets or 
        (x, y+1) in targets or 
        (x, y-1) in targets):
            return True
        else:
            return False

    # Find the closest goal to current white piece
    def find_closest_goal(piece, goals):
        closest = None
        dist = 16
        for place in goals:
            if (abs((piece[0]-place[0]) + (piece[1]-place[1]))) < dist:
                dist = abs((piece[0]-place[0]) + (piece[1]-place[1]))
                closest = place
        return closest

    # Iterative Deepening Search to find paths
    def it_deepening(board, path, attacker, goals, max_depth=10):
        for depth in range(1, max_depth):

            result = WatchYourBack.depth_limited_search(board, attacker, goals,
                                                        depth)

            if result is not None:
                return result
            else:
                continue

    # Searching algorithm function: Depth Limited Search
    def depth_limited_search(board, start, goals, depth):
        SENTINEL = object()
        path = []
        visited = [start]

        while visited:

            current = visited.pop()
            # once goal state reached, return the path to it
            if current in goals:
                path.append(current)
                return path

            # if the depth is reached without reaching goal, increase depth
            #   & start again
            elif current == SENTINEL:
                depth += 1
                if len(path) > 0:
                    path.pop()

            # if goal isn't reached but depth hasn't been reached, keep
            #   searching through available moves
            elif depth != 0:
                depth -= 1
                path.append(current)
                visited.append(SENTINEL)
                visited.extend(WatchYourBack.append_moves(board, current[0],
                                                          current[1], path))

# ------------------------MOVES------------------------

    def moves(board):
        # Initialise moves variables
        moves_O = 0
        moves_at = 0

        # For each square on board:
        #       - check if it's a piece
        #       - if so, count avaliable moves

        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    # Check avaliable spaces
                    moves_O += WatchYourBack.check_moves(board, x, y)

                # Count available moves for black
                elif board[x][y] is black:
                    moves_at += 1
                    (board, x, y)

        print(str(moves_O) + "\n" + str(moves_at))
        return [moves_O,  moves_at]

# ---------------------MASSACRE----------------------

    def massacre(board):  # put in corner squares!!!!

        moves = []
        END = object()

        # Store locations of Black and White pieces
        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    attackers.append((x, y))

                elif board[x][y] is black:
                    targets.append((x, y))


        # find all positions that will eliminate a target
        goals = []
        flanks = []
        for i in targets:
            x = i[0]
            y = i[1]
            returns = WatchYourBack.find_goal_pos([], [], x, y)
            for goal in returns[0]:
                if goal not in goals:
                    goals.append(goal)
            for flank in returns[1]:
                if flank not in flanks:
                    flanks.append(flank)

        # While all black pieces are not dead
        while len(targets) > 0:
            
            for attacker in attackers:
                    
                # if attacker is not being helpful, move it to goal
                if not WatchYourBack.in_goal_pos(targets, attacker[0],
                 attacker[1]):
                 
                    path = WatchYourBack.it_deepening(board, [],
                                                      attacker, goals)

                    # if no path found, try next attacker
                    if path is None:
                        continue

                    # store path from position to goal
                    moves.extend(path)
                    moves.append(END)

                    # Convert string to list to update board
                    s = list(board[attacker[0]])
                    s[attacker[1]] = empty
                    board[attacker[0]] = "".join(s)

                    s = list(board[moves[-2][0]])
                    s[moves[-2][1]] = white
                    board[moves[-2][0]] = "".join(s)

                    # Remove current goal from goal list
                    for goal in goals:
                        if len(moves) > 1:
                            if goal == moves[-2]:
                                goals.remove(goal)

                    # Move white to white_goal_list
                    if len(moves) > 1:
                        flanks.append(moves[-2])
                        attackers.pop(attackers.index(attacker))

                    # -----Check if target is dead-----
                    # find opposite flank

                    # Initialise x and y
                    x = -3
                    y = -3
                    if len(moves) > 1:
                        (x, y) = moves[-2]
                    flank_pos = []
                    curr_target = []
                    if (x+2 in range(8)) and (board[x+1][y] is black):
                        curr_target.append((x+1, y))
                        flank_pos.append((x+2, y))
                    if (x-2 in range(8)) and (board[x-1][y] is black):
                        curr_target.append((x-1, y))
                        flank_pos.append((x-2, y))
                    if (y+2 in range(8)) and (board[x][y+1] is black):
                        curr_target.append((x, y+1))
                        flank_pos.append((x, y+2))
                    if (y-2 in range(8)) and (board[x][y-1] is black):
                        curr_target.append((x,  y-1))
                        flank_pos.append((x, y-2))

                    # if opposite flank is also in flanking list
                    for f in flank_pos:
                        if (f in flanks) or (board[f[0]][f[1]] is corner):
                            # target dead

                            (flank_x, flank_y) = f

                            # remove current target from target list
                            #   as it's dead
                            target_to_remove = curr_target[flank_pos.index(f)]

                            targets.remove(target_to_remove)
                            
                            # remove target from board and replace with 
                            # symbol for empty
                            s = list(board[target_to_remove[0]])
                            s[target_to_remove[1]] = empty
                            board[target_to_remove[0]] = "".join(s)

                            if len(targets) == 0:
                                break

                            WatchYourBack.remove_goal_pos(goals, curr_target[
                                                          flank_pos.index(f)][0],
                                                          curr_target[
                                                          flank_pos.index(f)][1])

                            # move associated flankers from flanker list to
                            #   attackers if coords no longer in goal list
                            if ((x, y) not in goals and
                               (x+1, y) not in targets and 
                               (x-1, y) not in targets and 
                               (x, y+1) not in targets and 
                               (x, y-1) not in targets):
                                    attackers.append(flanks.pop(
                                                     flanks.index((x, y))))

                            WatchYourBack.move_flank_to_attack(board, goals, 
                            attackers, flanks, f[0], f[1])
                            
                            if (x+1,y) in flanks:
                                WatchYourBack.move_flank_to_attack(targets, 
                                goals, attackers, flanks, x+1, y)
                            if (x-1,y) in flanks:
                                WatchYourBack.move_flank_to_attack(targets, 
                                goals, attackers,flanks, x-1, y)
                            if (x,y+1) in flanks:
                                WatchYourBack.move_flank_to_attack(targets, 
                                goals, attackers,flanks, x, y+1)
                            if (x,y-1) in flanks:
                                WatchYourBack.move_flank_to_attack(targets, 
                                goals, attackers,flanks, x, y-1)
                            

        # Print list of moves from position to goal
        for i in range(len(moves)-1):
            if moves[i] != END and moves[i+1] != END:
                print(str(moves[i]) + " -> " + str(moves[i+1]))

        return moves


# --------------------MAIN----------------------

# initialise board matrix
board = [[0 for col in range(8)] for row in range(8)]
attackers = []
targets = []
goals = []
flanks = []

# Load board and game_type
for i in range(8):
    line = input()
    board[i] = line.replace(" ", "")
game_type = input()

# Check game_type

if game_type == "Moves":
    WatchYourBack.moves(board)
elif game_type == "Massacre":
    WatchYourBack.massacre(board)
