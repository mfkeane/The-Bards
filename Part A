#-----------START OF SOURCED CODE------------
# The following code is sourced from:
# Lynn Root (screen name: econchick) (30/01/2013) Python implementation of Dijkstra's Algorithm (Version 1.0) [source code]. https://gist.github.com/econchick/4666413
class Graph:
  def __init__(self):
    self.nodes = set()
    self.edges = defaultdict(list)
    self.distances = {}

  def add_node(self, value):
    self.nodes.add(value)

  def add_edge(self, from_node, to_node, distance):
    self.edges[from_node].append(to_node)
    self.edges[to_node].append(from_node)
    self.distances[(from_node, to_node)] = distance


def dijsktra(graph, initial):
  visited = {initial: 0}
  path = {}

  nodes = set(graph.nodes)

  while nodes: 
    min_node = None
    for node in nodes:
      if node in visited:
        if min_node is None:
          min_node = node
        elif visited[node] < visited[min_node]:
          min_node = node

    if min_node is None:
      break

    nodes.remove(min_node)
    current_weight = visited[min_node]

    for edge in graph.edges[min_node]:
      weight = current_weight + graph.distance[(min_node, edge)]
      if edge not in visited or weight < visited[edge]:
        visited[edge] = weight
        path[edge] = min_node

  return visited, path
        
 #------------END OF SOURCED CODE-------------
 
 #------------------HELPER FUNCTIONS-----------------

# Function to check the avaliable moves surrounding a piece

def CheckMoves(board, x, y):
    moves = 0
    if board[x+1][y] is '-':
        moves+=1
    if board[x-1][y] is '-':
        moves+=1
    if board[x][y+1] is '-':
        moves+=1
    if board[x][y-1] is '-':
        moves+=1
        
    if (x+2 in range(8)) and (board[x+1][y] is 'O' or '@') and (board[x+2][y] is '-'):
        moves+=1
    if (x-2 in range(8)) and (board[x-1][y] is 'O' or '@') and (board[x-2][y] is '-'):
        moves+=1
    if (y+2 in range(8)) and (board[x][y+1] is 'O' or '@') and (board[x][y+2] is '-'):
        moves+=1
    if (y-2 in range(8)) and (board[x][y-1] is 'O' or '@') and (board[x][y-2] is '-'):
        moves+=1
        
    return moves
    
# Check if piece already partially surrounded and mark goal positions for white

def find_goal_pos(goals,flanks,x,y):

    # If no white pieces surround black, all surrounding tiles are valid goals

    if (board[x+1][y] is empty and board[x-1][y] is empty
    and board[x][y+1] is empty and board[x][y-1] is empty):

        goals.append((x+1,y))
        goals.append((x-1,y))
        goals.append((x,y+1))
        goals.append((x,y-1))

    # If piece already surrounded by one white piece, adjacent square is goal

    if (board[x+1][y] is white):
        goals.append((x-1,y))
        flanks.append(attackers.pop(attackers.index((x+1,y))))
    if (board[x-1][y] is white):
        goals.append((x+1,y))
        flanks.append(attackers.pop(attackers.index((x-1,y))))
    if (board[x][y+1] is white):
        goals.append((x,y-1))
        flanks.append(attackers.pop(attackers.index((x,y+1))))
    if (board[x][y-1] is white):
        goals.append((x,y+1))
        flanks.append(attackers.pop(attackers.index((x,y-1))))
    
    return [goals,flanks]

def in_goal_pos(x,y):

    # Check that the white piece is in a goal pos

    if (board[x+1][y] is black or board[x-1][y] is black
    or board[x][y+1] is black or board[x][y-1] is black):
        return True
    else
        return False

def check_taken(x,y):


def check_win(board):


# --------------------MAIN----------------------



def CheckMoves(board, x, y):
    moves = 0
    if (x+1 in range(8)) and board[x+1][y] is '-':
        moves+=1
    if (x-1 in range(8)) and board[x-1][y] is '-':
        moves+=1
    if (y+1 in range(8)) and board[x][y+1] is '-':
        moves+=1
    if (y-1 in range(8)) and board[x][y-1] is '-':
        moves+=1

    if (x+2 in range(8)) and ((board[x+1][y] is 'O') or (board[x+1][y] is '@'))$
        moves+=1
    if (x-2 in range(8)) and ((board[x-1][y] is 'O') or (board[x-1][y] is '@'))$
        moves+=1
    if (y+2 in range(8)) and ((board[x][y+1] is 'O') or (board[x][y+1] is '@'))$
        moves+=1
    if (y-2 in range(8)) and ((board[x][y-1] is 'O') or (board[x][y-1] is '@'))$
        moves+=1

    return moves


#Define symbols
empty = '-'
white = 'O'
black = '@'

# initialise board matrix
board = [[0 for col in range(8)] for row in range(8)]
attackers = []
targets = []
goals = []
flanks = []

# Load board and game_type
for i in range(8):
    line = input()
    board[i] = line.replace(" ","")
game_type = input()
print(game_type)

# Check game_type
#------------------------MOVES------------------------
if game_type == "Moves":

    # Initialise moves variables
    moves_O = 0
    moves_at = 0

    # For each square on board:
    #       - check if it's a piece
    #       - if so, count avaliable moves


# Load board and game_type
for i in range(8):
    line = input()
    board[i] = line.replace(" ","")
game_type = input()
print(game_type)

# Check game_type
#------------------------MOVES------------------------
if game_type == "Moves":

    # Initialise moves variables
    moves_O = 0
    moves_at = 0

    # For each square on board:
    #       - check if it's a piece
    #       - if so, count avaliable moves

    for x in range(8):
        for y in range(8):
            if board[x][y] is white:
                #Check avaliable spaces
                moves_O += CheckMoves(board,x,y)
                print("white" + str(x) + "," + str(y) + "," + str(moves_O))

            elif board[x][y] is black:
                #Check avaliable spaces
                moves_at += CheckMoves(board,x,y)
                print("black" + str(x) + "," + str(y) + "," + str(moves_O))


    print(str(moves_O) + "\n" + str(moves_at))
    
#---------------------MASSACRE----------------------
elif input is Massacre:
    # Store locations of Black and White pieces
    
    num_white = 0
    num_black = 0

    for x in range(8):
       for y range(8):
           if board[x][y] is white:
               attackers.append((x,y))
               num_white += 1

           elif board[x][y] is black:
               targets.append((x,y))
               num_black += 1

    for i in targets:
        x = i[0]
        y = i[1]
        returns = find_goal_pos(goals, flanks,x,y)
        goals = returns[0]
        flanks = returns[1]
           
    for j in range(len(targets)):
        curr_target_x = targets[j][0]
        curr_target_y = targets[j][1]
        closest_white_x = attackers[0][0]
        closest_white_y = attackers[0][1]
       
    for k in range(len(attackers)):
        if((abs(curr_target_x-attackers[k][0]) <
        abs(curr_target_x-closest_white_x)) &
        (abs(curr_target_y - attackers[k][1]) <
        abs(curr_target_y - closest_white_y)))

            closest_white_x = attackers[k][0]
            closest_white_y = attackers[k][1]
                      
    for i in range(len(attackers)):
    # if attacker is not being helpful, put it somewhere better
        if not in_goal_pos(attackers[i]):
            it_depth_search(attackers[i])
          
            #put all path data to move_list
           
            # Remove current goal from goal list
            goals.remove(attackers[i])
           
            #move O to O_goal_list
            flanks.append(attackers.pop(attackers[i]))
           
            # -----Check if target is dead-----
            # find opposite flank
            (x,y) = attackers[i]
            (x_tar, y_tar) = curr_target
            flanker = (x+(x_tar-x), y+(y_tar-y))
           
            # if opposite flank is also in flanking list
            if flanker in flanks:
                # target dead
             
                # remove all associated goal's from list (except already removed one)
                for coord in find_goal_pos([],[],x_tar, y_tar)[0]:
                    if coord is not attackers[i]:
                        goals.remove(coord)
                       
                # remove current target from target list as it's dead
                targets.remove(curr_target)
               
                # move associated flankers from flanker list to attackers if coords no longer in goal list
                if (x,y) not in goals:
                    attackers.append(flanks.pop(attackers[i]))
                if flanker not in goals:
                    attackers.append(flanks.pop(flanker))


