#Constants
empty = '-'
white = 'O'
black = '@'
corner = 'X'

class WatchYourBack:

    # Function to check the avaliable moves surrounding a piece
    def check_moves(board, x, y):
        moves = 0
        if (x+1 in range(8)) and (board[x+1][y] is '-'):
            moves+=1
        if (x-1 in range(8)) and (board[x-1][y] is '-'):
            moves+=1
        if (y+1 in range(8)) and (board[x][y+1] is '-'):
            moves+=1
        if (y-1 in range(8)) and (board[x][y-1] is '-'):
            moves+=1

        if (x+2 in range(8)) and ((board[x+1][y] is 'O')
        or (board[x+1][y] is '@')):
            moves+=1
        if (x-2 in range(8)) and ((board[x-1][y] is 'O')
        or (board[x-1][y] is '@')):
            moves+=1
        if (y+2 in range(8)) and ((board[x][y+1] is 'O')
        or (board[x][y+1] is '@')):
            moves+=1
        if (y-2 in range(8)) and ((board[x][y-1] is 'O')
        or (board[x][y-1] is '@')):
            moves+=1

        return moves

    # Appends avaliable moves to a list
    def append_moves(board, x, y, path):
        moves = []
        if (x+1 in range(8)) and board[x+1][y] is '-':
            if (x+1,y) not in path:
                moves.append((x+1,y))
        if (x-1 in range(8)) and board[x-1][y] is '-':
            if (x-1,y) not in path:
                moves.append((x-1,y))
        if (y+1 in range(8)) and board[x][y+1] is '-':
            if (x,y+1) not in path:
                moves.append((x,y+1))
        if (y-1 in range(8)) and board[x][y-1] is '-':
            if (x,y-1) not in path:
                moves.append((x,y-1))

        if (x+2 in range(8)) and ((board[x+1][y] is 'O')
        or (board[x+1][y] is '@')) and board[x+2][y] is '-':
            if (x+2,y) not in path:
                moves.append((x+2,y))
        if (x-2 in range(8)) and ((board[x-1][y] is 'O')
        or (board[x-1][y] is '@')) and board[x-2][y] is '-':
            if (x-2,y) not in path:
                moves.append((x-2,y))
        if (y+2 in range(8)) and ((board[x][y+1] is 'O')
        or (board[x][y+1] is '@')) and board[x][y+2] is '-':
            if (x,y+2) not in path:
                moves.append((x,y+2))
        if (y-2 in range(8)) and ((board[x][y-1] is 'O')
        or (board[x][y-1] is '@')) and board[x][y-2] is '-':
            if (x,y-2) not in path:
                moves.append((x,y-2))

        return moves

    # Check if piece already partially surrounded
    #   and mark goal positions for white
    def find_goal_pos(goals,flanks,x,y):

        # If no white pieces surround black,
        #   all surrounding tiles are valid goals
        
        if (board[x+1][y] is empty and board[x-1][y] is empty
        and board[x][y+1] is empty and board[x][y-1] is empty): #do we need to check if range?

            goals.append((x+1,y))
            goals.append((x-1,y))
            goals.append((x,y+1))
            goals.append((x,y-1))

        # If piece already surrounded by one white piece,
        #   adjacent square is goal

        if ((x+1 in range(8)) and board[x+1][y] is white):
            goals.append((x-1,y))
            flanks.append(attackers.pop(attackers.index((x+1,y))))
        if ((x-1 in range(8)) and board[x-1][y] is white):
            goals.append((x+1,y))
            flanks.append(attackers.pop(attackers.index((x-1,y))))
        if ((y+1 in range(8)) and board[x][y+1] is white):
            goals.append((x,y-1))
            flanks.append(attackers.pop(attackers.index((x,y+1))))
        if ((y-1 in range(8)) and board[x][y-1] is white):
            goals.append((x,y+1))
            flanks.append(attackers.pop(attackers.index((x,y-1))))

        return [goals,flanks]

    def remove_goal_pos(goals,x,y):
      
        if (x+1,y) in goals:
            goals.remove((x+1,y))
        if (x-1,y) in goals:
            goals.remove((x-1,y))
        if (x,y+1) in goals:
            goals.remove((x,y+1))
        if (x,y-1) in goals:
            goals.remove((x,y-1))

    def in_goal_pos(x,y):

        # Check that the white piece is in a goal pos

        if (board[x+1][y] is black or board[x-1][y] is black
        or board[x][y+1] is black or board[x][y-1] is black):
            return True
        else:
            return False

    def find_closest_goal(piece,goals):
        closest = None
        dist = 16
        for place in goals:
            if (abs((piece[0]-place[0])+(piece[1]-place[1])))<dist:
                dist = abs((piece[0]-place[0])+(piece[1]-place[1]))
                closest = place
        return closest


   
    def it_deepening(board, path, attacker, goals, max_depth=10):
        for depth in range(1, max_depth):
        
            result = WatchYourBack.depth_limited_search(board, attacker, goals,
             depth)
         
            if result != None:
                return result
            else:
              continue
    
    # Searching algorithm function: Depth Limited Search
    def depth_limited_search(board, start, goals, depth):
        SENTINEL = object()
        path = []
        visited = [start]
        
        while visited:
            current = visited.pop()
            if current in goals:
                path.append(current)
                return path
                
            elif current == SENTINEL:
                depth += 1
                if len(path)>0:
                    path.pop()
                
            elif depth != 0:
                depth -= 1
                path.append(current)
                visited.append(SENTINEL)
                visited.extend(WatchYourBack.append_moves(board, current[0], 
                current[1], path))
        
#------------------------MOVES------------------------

    def moves(board):
        # Initialise moves variables
        moves_O = 0
        moves_at = 0

        # For each square on board:
        #       - check if it's a piece
        #       - if so, count avaliable moves

        for x in range(8):
            for y in range(8):
                if board[x][y] is white:
                    #Check avaliable spaces
                    moves_O += WatchYourBack.check_moves(board,x,y)

                elif board[x][y] is black:
                    #Check avaliable spaces
                    moves_at += 1
                    (board,x,y)


        print(str(moves_O) + "\n" + str(moves_at))
        return [moves_O, moves_at]

#---------------------MASSACRE----------------------

    def massacre(board): #put in corner squares

        moves = []
        goals = []
        flanks = []
        END = object()
        
        # Store locations of Black and White pieces
        for x in range(8):
           for y in range(8):
               if board[x][y] is white:
                   attackers.append((x,y))

               elif board[x][y] is black:
                   targets.append((x,y))
        for i in targets:
            x = i[0]
            y = i[1]
            returns = WatchYourBack.find_goal_pos(goals, flanks,x,y)
            goals = returns[0]
            flanks = returns[1]
            
        # While all black pieces are not dead
        while len(targets)>0:
            for attacker in attackers:
            #for i in range(len(attackers)):
            # if attacker is not being helpful, put it somewhere better
                if not WatchYourBack.in_goal_pos(attacker[0], attacker[1]):
                    path = WatchYourBack.it_deepening(board, [], 
                    attacker, goals)
                    
                    # if no path found, try next attacker
                    if path == None:
                        continue
                    moves.extend(path)
                    moves.append(END)
                    
                    s = list(board[attacker[0]])
                    s[attacker[1]] = empty
                    board[attacker[0]] = "".join(s)
                    
                    s = list(board[moves[-2][0]])
                    s[moves[-2][1]] = white
                    board[moves[-2][0]] = "".join(s)
                    
                    # Remove current goal from goal list
                    for  goal in goals:
                        if len(moves)>1:
                            if goal == moves[-2]:
                                goals.remove(goal)

                    #move O to O_goal_list
                    if len(moves)>1:
                        flanks.append(moves[-2])
                        attackers.pop(attackers.index(attacker))
                  
                    """for j in range(len(goals)):
                        if attackers[i] in goals:
                            goals.remove(attackers[i])"""

                    # -----Check if target is dead-----
                    # find opposite flank
                    x = -3
                    y = -3
                    if len(moves)>1:
                        (x,y) = moves[-2]
                    flanker = []
                    curr_target = []
                    if (x+2 in range(8)) and (board[x+1][y] is black):
                        curr_target.append((x+1,y))
                        flanker.append((x+2,y))
                    if (x-2 in range(8)) and (board[x-1][y] is black):
                        curr_target.append((x-1,y))
                        flanker.append((x-2,y))
                    if (y+2 in range(8)) and (board[x][y+1] is black):
                        curr_target.append((x,y+1))
                        flanker.append((x,y+2))
                    if (y-2 in range(8)) and (board[x][y-1] is black):
                        curr_target.append((x, y-1))
                        flanker.append((x, y-2))

                    #(flank_x, flank_y) = flanker
                    """#(x,y) = attacker
                    #(x_tar, y_tar) = curr_target
                    flanker = (x+(x_tar-x), y+(y_tar-y)) """

                    # if opposite flank is also in flanking list
                    for f in flanker:
                        if (f in flanks) or (board[f[0]][f[1]] is corner):
                            # target dead
                            (flank_x, flank_y) = f
                            
                            # remove current target from target list as it's dead
                            target_to_remove = curr_target[flanker.index(f)]
                            targets.remove(target_to_remove)
                            s = list(board[target_to_remove[0]])
                            s[target_to_remove[1]] = empty
                            board[target_to_remove[0]] = "".join(s)
                            
                            if len(targets)==0:
                                break
                            
                            WatchYourBack.remove_goal_pos(goals,curr_target[
                            flanker.index(f)][0],curr_target[
                            flanker.index(f)][1])

                            # move associated flankers from flanker list to
                            #   attackers if coords no longer in goal list
                            if ((x,y) not in goals 
                            and (y-1 in range(8)
                            and board[x][y-1] is not black)
                            and (y+1 in range(8)
                            and board[x][y+1] is not black)
                            and (x-1 in range(8)
                            and board[x-1][y] is not black)
                            and (x+1 in range(8)
                            and board[x+1][y] is not black)):
                                attackers.append(flanks.pop(
                                    flanks.index((x,y))))
                               
                                
                            if (f not in goals
                            and (board[f[0]][f[1]] is not corner)
                            and (flank_y-1 in range(8)
                            and board[flank_x][flank_y-1] is not black)
                            and (flank_y+1 in range(8)
                            and board[flank_x][flank_y+1] is not black)
                            and (flank_x-1 in range(8)
                            and board[flank_x-1][flank_y] is not black)
                            and (flank_x+1 in range(8)
                            and board[flank_x+1][flank_y] is not black)):
                                attackers.append(flanks.pop(flanks.index(f)))
                                

        for i in range(len(moves)-1):
            if moves[i] != END and moves[i+1] != END:
                print(str(moves[i]) + " -> " + str(moves[i+1]))

        return moves


# --------------------MAIN----------------------

# initialise board matrix
board = [[0 for col in range(8)] for row in range(8)]
attackers = []
targets = []
goals = []
flanks = []

# Load board and game_type
for i in range(8):
    line = input()
    board[i] = line.replace(" ","")
game_type = input()

# Check game_type

if game_type == "Moves":
    WatchYourBack.moves(board)
elif game_type == "Massacre":
    WatchYourBack.massacre(board)
